// <copyright file="AutoMapPropertiesGenerator.cs" company="Klaus-Fischer-Inc">
// Copyright (c) Klaus-Fischer-Inc. All rights reserved.
// </copyright>

namespace SIM.Mvvm.CodeGeneration
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp.Syntax;

    internal class GeneratePropertiesGenerator : IContentGenerator
    {
        const string attributeFullName = "SIM.Mvvm.CodeGeneration.GeneratePropertyAttribute";
        const string attributeContent = @"
namespace SIM.Mvvm.CodeGeneration
{
    using System;

    /// <summary>
    /// Generates an property getter and setter to this field.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
    public class GeneratePropertyAttribute : Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref=""GeneratePropertyAttribute""/> class.
        /// </summary>
        /// <param name=""setterVisibility"">Property will have no getter.</param>
        public SIM.Mvvm.CodeGeneration(SetterVisibility setterVisibility = SetterVisibility.Public)
        {
            this.SetterVisibility = setterVisibility;
        }

        /// <summary>
        /// Gets a value indicating whether property should be read-only.
        /// </summary>
        public SetterVisibility SetterVisibility { get; }
    }
}
";

        private readonly string ViewModelFullName = typeof(ViewModel).FullName;
        private readonly List<IFieldSymbol> fieldsToGeneratePropertiesFrom = new();

        public void PostInititialize(GeneratorPostInitializationContext context)
        {
            context.AddSource($"GeneratePropertyAttribute.g.cs", attributeContent);
        }

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context.Node is FieldDeclarationSyntax fieldDeclarationSyntax
                && fieldDeclarationSyntax.AttributeLists.Count > 0)
            {
                foreach (var variable in fieldDeclarationSyntax.Declaration.Variables)
                {
                    // Get the symbol being declared by the field, and keep it if its annotated
                    if (context.SemanticModel.GetDeclaredSymbol(variable) is IFieldSymbol fieldSymbol)
                    {
                        if (fieldSymbol.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == attributeFullName))
                        {
                            this.fieldsToGeneratePropertiesFrom.Add(fieldSymbol);
                        }
                    }
                }
            }
        }

        /// <inheritdoc/>
        public void Execute(GeneratorExecutionContext context)
        {
            // group the fields by class, and generate the source
            foreach (var group in this.fieldsToGeneratePropertiesFrom.GroupBy(f => f.ContainingType))
            {
                var classSource = this.ProcessClass(group.Key, group.ToList());
                context.AddSource($"{group.Key.Name}.properties.cs", classSource);
            }
        }

        private string ProcessClass(
            INamedTypeSymbol classSymbol,
            List<IFieldSymbol> fields)
        {
            //System.Diagnostics.Debugger.Launch();

            if (!this.CheckClass(classSymbol, out string namespaceName))
            {
                return string.Empty;
            }

            var properties = this.GetPropertyAttributeDescriptions(classSymbol, fields).ToArray();

            // begin building the generated source
            var writer = new StringBuilder($@"// <summary>
// This file is automatically generated by 'SIM.Mvvm.CodeGenerator' nuget package.
// </summary>

namespace {namespaceName}
{{
    public partial class {classSymbol.Name}
    {{");

            foreach (var property in properties)
            {
                if (property.IsValid)
                {
                    writer.Append($@"
        /// <summary>
        /// Gets or sets the value of the <see cref=""{property.FieldName}""/> field.
        /// </summary>
        public {property.PropertyTypeNamespace}.{property.PropertyType} {property.PropertyName} 
        {{
            get => this.{property.FieldName};
            {property.SetterVisibility}set => this.SetPropertyValue(ref this.{property.FieldName}, value);
        }}
");
                }
                else
                {
                    writer.Append($@"
        // {property.FieldName} {property.ExcludeMessage}
");
                }
            }

            writer.Append($@"    }}
}}");
            return writer.ToString();
        }

        private bool CheckClass(
            INamedTypeSymbol classSymbol,
            out string @namespace)
        {
            @namespace = string.Empty;

            if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
            {
                return false;
            }

            if (!this.CheckDerived(classSymbol))
            {
                return false; ;
            }

            @namespace = classSymbol.ContainingNamespace.ToDisplayString();
            return true;
        }

        private bool CheckDerived(INamedTypeSymbol? classSymbol)
        {
            while (classSymbol.GetFullName() != ViewModelFullName)
            {
                classSymbol = classSymbol?.BaseType;

                if (classSymbol is null)
                {
                    return false;
                }
            }

            return true;
        }

        private IEnumerable<GeneratePropertyAttributeDescription> GetPropertyAttributeDescriptions(
            INamedTypeSymbol classSymbol,
            List<IFieldSymbol> fieldCollection)
        {
            var knownProperties = classSymbol.GetMembers()
                .Where(o => o.Kind == SymbolKind.Property)
                .Select(o => o.Name)
                .ToList();

            // create properties for each field
            foreach (var field in fieldCollection)
            {
                if (!this.TryGetSymbolType(field, out var type, out var setterVisibility))
                {
                    continue;
                }

                this.CheckExclusion(field, knownProperties, out string message);

                var propertyName = field.Name.TrimStart('_');
                propertyName = propertyName.Substring(0, 1).ToUpper() + propertyName.Substring(1);

                yield return new GeneratePropertyAttributeDescription()
                {
                    ExcludeMessage = message,
                    PropertyTypeNamespace = field.Type.ContainingNamespace.ToDisplayString(),
                    PropertyType = field.Type.Name,
                    FieldName = field.Name,
                    PropertyName = propertyName,
                    SetterVisibility = setterVisibility,
                };

            }
        }

        private bool TryGetSymbolType(ISymbol symbol, out ITypeSymbol type, out string setterVisibility)
        {
            setterVisibility = string.Empty;

            if (symbol is IFieldSymbol fieldSymbol)
            {
                type = fieldSymbol.Type;

                if (fieldSymbol.GetAttributes().FirstOrDefault(o => o.AttributeClass?.ToDisplayString() == attributeFullName) is AttributeData attribute)
                {
                    if (attribute.ConstructorArguments.FirstOrDefault() is TypedConstant tc)
                    {
                        if (tc.Value is int visibility)
                        {
                            setterVisibility = visibility switch
                            {
                                0 => "private ",
                                1 => "protected ",
                                2 => "internal ",
                                _ => "",
                            };
                        }
                    }
                }

                return true;
            }

            type = symbol.ContainingType;
            return false;
        }

        private void CheckExclusion(IFieldSymbol fieldSymbol, ICollection<string> knownProperties, out string message)
        {
            if (knownProperties.Contains(fieldSymbol.Name))
            {
                message = $"skipped (already defined).";
                return;
            }

            knownProperties.Add(fieldSymbol.Name);
            message = string.Empty;
        }

    }
}
// <copyright file="AutoMapPropertiesGenerator.cs" company="Klaus-Fischer-Inc">
// Copyright (c) Klaus-Fischer-Inc. All rights reserved.
// </copyright>

namespace SIM.Mvvm.CodeGeneration
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Text;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.Text;

    internal class GeneratePropertiesGenerator
    {
        private readonly SyntaxReceiver receiver;
        private readonly string ViewModelFullName = typeof(ViewModel).FullName;
        private readonly string? AttributeFullName = SyntaxReceiver.GeneratePropertyAttributeFullName;

        public GeneratePropertiesGenerator(SyntaxReceiver receiver)
        {
            this.receiver = receiver;
        }

        /// <inheritdoc/>
        public void Execute(GeneratorExecutionContext context)
        {
            // group the fields by class, and generate the source
            foreach (var group in this.receiver.FieldsToGeneratePropertiesFrom.GroupBy(f => f.ContainingType))
            {
                var classSource = this.ProcessClass(group.Key, group.ToList());
                context.AddSource($"{group.Key.Name}.properties.cs", SourceText.From(classSource, Encoding.UTF8));
            }
        }

        private string ProcessClass(
            INamedTypeSymbol classSymbol,
            List<IFieldSymbol> fields)
        {
            //System.Diagnostics.Debugger.Launch();

            if (!this.CheckClass(classSymbol, out string namespaceName))
            {
                return string.Empty;
            }

            var properties = this.GetPropertyAttributeDescriptions(classSymbol, fields).ToArray();

            // begin building the generated source
            var writer = new StringBuilder($@"// <summary>
// This file is automatically generated by 'SIM.Mvvm.CodeGenerator' nuget package.
// </summary>

namespace {namespaceName}
{{
    public partial class {classSymbol.Name}
    {{");

            foreach (var property in properties)
            {
                if (property.IsValid)
                {
                    writer.Append($@"
        /// <summary>
        /// Gets or sets the value of the <see cref=""{property.FieldName}""/> field.
        /// </summary>
        public {property.PropertyTypeNamespace}.{property.PropertyType} {property.PropertyName} 
        {{
            get => this.{property.FieldName};
            {property.SetterVisibility}set => this.SetPropertyValue(ref this.{property.FieldName}, value);
        }}
");
                }
                else
                {
                    writer.Append($@"
        // {property.FieldName} {property.ExcludeMessage}
");
                }
            }

            writer.Append($@"    }}
}}");
            return writer.ToString();
        }

        private bool CheckClass(
            INamedTypeSymbol classSymbol,
            out string @namespace)
        {
            @namespace = string.Empty;

            if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
            {
                return false;
            }

            if (!this.CheckDerived(classSymbol))
            {
                return false; ;
            }

            @namespace = classSymbol.ContainingNamespace.ToDisplayString();
            return true;
        }

        private bool CheckDerived(INamedTypeSymbol? classSymbol)
        {
            while (classSymbol.GetFullName() != ViewModelFullName)
            {
                classSymbol = classSymbol?.BaseType;

                if (classSymbol is null)
                {
                    return false;
                }
            }

            return true;
        }

        private IEnumerable<GeneratePropertyAttributeDescription> GetPropertyAttributeDescriptions(
            INamedTypeSymbol classSymbol,
            List<IFieldSymbol> fieldCollection)
        {
            var knownProperties = classSymbol.GetMembers()
                .Where(o => o.Kind == SymbolKind.Property)
                .Select(o => o.Name)
                .ToList();

            // create properties for each field
            foreach (var field in fieldCollection)
            {
                if (!this.TryGetSymbolType(field, out var type, out var setterVisibility))
                {
                    continue;
                }

                this.CheckExclusion(field, knownProperties, out string message);

                var propertyName = field.Name.TrimStart('_');
                propertyName = propertyName.Substring(0, 1).ToUpper() + propertyName.Substring(1);

                yield return new GeneratePropertyAttributeDescription()
                {
                    ExcludeMessage = message,
                    PropertyTypeNamespace = field.Type.ContainingNamespace.ToDisplayString(),
                    PropertyType = field.Type.Name,
                    FieldName = field.Name,
                    PropertyName = propertyName,
                    SetterVisibility = setterVisibility,
                };

            }
        }

        private bool TryGetSymbolType(ISymbol symbol, out ITypeSymbol type, out string setterVisibility)
        {
            setterVisibility = string.Empty;

            if (symbol is IFieldSymbol fieldSymbol)
            {
                type = fieldSymbol.Type;

                if (fieldSymbol.GetAttributes().FirstOrDefault(o => o.AttributeClass?.ToDisplayString() == AttributeFullName) is AttributeData attribute)
                {
                    if (attribute.ConstructorArguments.FirstOrDefault() is TypedConstant tc)
                    {
                        if (tc.Value is not SetterVisibility visibility)
                        {
                            if (tc.Value is not int enumValue)
                            {
                                return true;
                            }

                            visibility = (SetterVisibility)enumValue;
                        }

                        setterVisibility = visibility switch
                        {
                            SetterVisibility.Private => "private ",
                            SetterVisibility.Internal => "internal ",
                            SetterVisibility.Protected => "protected ",
                            _ => "",
                        };
                    }
                }

                return true;
            }

            type = symbol.ContainingType;
            return false;
        }


        private void CheckExclusion(IFieldSymbol fieldSymbol, ICollection<string> knownProperties, out string message)
        {
            if (knownProperties.Contains(fieldSymbol.Name))
            {
                message = $"skipped (already defined).";
                return;
            }

            knownProperties.Add(fieldSymbol.Name);
            message = string.Empty;
        }
    }
}
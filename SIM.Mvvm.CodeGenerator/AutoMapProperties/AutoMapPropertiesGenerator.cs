// <copyright file="AutoMapPropertiesGenerator.cs" company="Klaus-Fischer-Inc">
// Copyright (c) Klaus-Fischer-Inc. All rights reserved.
// </copyright>

namespace SIM.Mvvm.CodeGeneration
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.Text;

    internal partial class AutoMapPropertiesGenerator
    {
        private static readonly string AttributeFullName = SyntaxReceiver.AutoMapPropertiesAttributeFullName;
        private static readonly string ViewModelFullName = typeof(ViewModel).FullName;

        private readonly SyntaxReceiver receiver;

        public AutoMapPropertiesGenerator(SyntaxReceiver receiver)
        {
            this.receiver = receiver;
        }

        /// <inheritdoc/>
        public void Execute(GeneratorExecutionContext context)
        {
            // group the fields by class, and generate the source
            foreach (var group in receiver.FieldsToAutoMapProperties.GroupBy(f => f.ContainingType))
            {
                var classSource = this.ProcessClass(group.Key, group.ToList());
                context.AddSource($"{group.Key.Name}_autoMap.cs", classSource);
            }
        }

        private string ProcessClass(
            INamedTypeSymbol classSymbol,
            List<ISymbol> fields)
        {
            //System.Diagnostics.Debugger.Launch();

            if (!this.CheckClass(classSymbol, out string namespaceName))
            {
                return string.Empty;
            }

            var properties = this.GetAutoGeneratedProperties(classSymbol, fields).ToArray();

            // begin building the generated source
            var writer = new StringBuilder($@"// <summary>
// This file is automatically generated by 'SIM.Mvvm.CodeGenerator' nuget package.
// </summary>

namespace {namespaceName}
{{
    public partial class {classSymbol.Name}
    {{");

            foreach (var property in properties)
            {
                if (property.IsValid)
                {
                    writer.Append($@"
        /// <summary>
        /// Gets or sets the <see cref=""{property.ModelType}.{property.PropertyName}""/> property of the <see cref=""{property.ModelName}""/> model.
        /// </summary>
        public {property.PropertyTypeNamespace}.{property.PropertyType} {property.PropertyName} 
        {{
            get => this.{property.ModelName}.{property.PropertyName};
            set => this.SetPropertyValue(() => this.{property.ModelName}.{property.PropertyName}, value);
        }}
");
                }
                else
                {
                    writer.Append($@"
        // {property.ModelName}.{property.PropertyName} {property.ExcludeMessage}
");
                }
            }

            writer.Append($@"    }}
}}");
            return writer.ToString();
        }

        private bool CheckClass(
            INamedTypeSymbol classSymbol,
            out string @namespace)
        {
            @namespace = string.Empty;

            if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
            {
                return false;
            }

            if (!this.CheckDerived(classSymbol))
            {
                return false; ;
            }

            @namespace = classSymbol.ContainingNamespace.ToDisplayString();
            return true;
        }

        private bool CheckDerived(INamedTypeSymbol? classSymbol)
        {
            while (classSymbol.GetFullName() != ViewModelFullName)
            {
                classSymbol = classSymbol?.BaseType;

                if (classSymbol is null)
                {
                    return false;
                }
            }

            return true;
        }

        private IEnumerable<AutoMapPropertyDescription> GetAutoGeneratedProperties(
            INamedTypeSymbol classSymbol,
            List<ISymbol> modelCollection)
        {
            var knownProperties = classSymbol.GetMembers()
                .Where(o => o.Kind == SymbolKind.Property || o.Kind == SymbolKind.Field)
                .Select(o => o.Name)
                .ToList();

            // create properties for each field
            foreach (var model in modelCollection)
            {
                if (!this.TryGetSymbolType(model, out var type))
                {
                    continue;
                }

                var excludedProperties = this.GetExcludedProperties(model);

                foreach (var modelProperty in type.GetMembers().Where(o =>
                    o.Kind == SymbolKind.Property &&
                    o.DeclaredAccessibility == Accessibility.Public && !o.IsStatic)
                    .OfType<IPropertySymbol>())
                {
                    if (modelProperty is null)
                    {
                        continue;
                    }

                    this.CheckExclusion(modelProperty, excludedProperties, knownProperties, out string message);

                    yield return new AutoMapPropertyDescription()
                    {
                        ExcludeMessage = message,
                        PropertyTypeNamespace = modelProperty.Type.ContainingNamespace.ToDisplayString(),
                        PropertyType = modelProperty.Type.Name,
                        PropertyName = modelProperty.Name,

                        ModelName = model.Name,
                        ModelType = type.Name,
                    };
                }
            }
        }

        private bool TryGetSymbolType(ISymbol symbol, out ITypeSymbol type)
        {
            if (symbol is IFieldSymbol fieldSymbol)
            {
                type = fieldSymbol.Type;
            }
            else if (symbol is IPropertySymbol property)
            {
                type = property.Type;
            }
            else
            {
                type = symbol.ContainingType;
                return false;
            }

            return true;
        }

        private string[] GetExcludedProperties(ISymbol symbol)
        {
            var attribute = symbol.GetAttributes()
                .First(ad => ad.AttributeClass?.ToDisplayString() == AttributeFullName);

            if (attribute is AttributeData ad)
            {
                if (ad.ConstructorArguments.Any())
                {
                    return ad.ConstructorArguments.SelectMany(o => o.Values).Select(o => o.Value).OfType<string>().ToArray();
                }
            }

            return Array.Empty<string>();
        }

        private void CheckExclusion(IPropertySymbol propertySymbol, IEnumerable<string> excludedProperties, ICollection<string> knownProperties, out string message)
        {
            if (excludedProperties.Contains(propertySymbol.Name))
            {
                message = $"skipped (Excluded).";
                return;
            }

            if (knownProperties.Contains(propertySymbol.Name))
            {
                message = $"skipped (already defined).";
                return;
            }

            knownProperties.Add(propertySymbol.Name);
            message = string.Empty;
        }
    }
}